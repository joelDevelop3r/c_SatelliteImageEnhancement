/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "filter.h"
#include <sys/resource.h>
struct rlimit limit;
#define MAX_W_PIXELS 8100 // máximo número de pixeles en una dimensión
#define MAX_H_PIXELS 8100
unsigned char pixels[MAX_H_PIXELS][MAX_W_PIXELS];
int rows, cols;
int mascara[3][3] = {{-1, -1, -1}, {-1, 9, -1}, {-1, -1, -1}}; // Máscara para el filtro de realce de bordes
unsigned char result[MAX_H_PIXELS][MAX_W_PIXELS];

/// @brief Use particular for filter algorithm
/// @param value 
/// @return 
unsigned char truncateMy(unsigned char value) {
    if (value < -50) {
        return value-30;
    } else if (value > 50) {
        return value+30;
    } else {
        return (unsigned char)value;
    }
}

/// @brief Abre el visor de imagenes mostrando output.pgm
void seeFile(){
    char command[256];
    sprintf(command, "eog output.pgm");
    system(command);
}

/// @brief Inicializa los valores de el array pixels con los pixeles del archivo input.pgm
/// @param filename 
/// @param img 
/// @param width 
/// @param height 
void read_pgm(char* filename, unsigned char img[MAX_H_PIXELS][MAX_W_PIXELS], int* width, int* height) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error: Could not open file %s\n", filename);
        exit(1);
    }
    
    char magic_num[3];
    fscanf(fp, "%s\n", magic_num);  // Read magic number, should be "P2"
    if (magic_num[0] != 'P' || magic_num[1] != '2') {
        printf("Error: Not a PGM file\n");
        exit(1);
    }
    
    fscanf(fp, "%d %d\n", width, height);  // Read width and height
    
    int max_val;
    fscanf(fp, "%d\n", &max_val);  // Read maximum pixel value
    
    if (max_val > 255) {
        printf("Error: This function only supports 8-bit PGM files\n");
        exit(1);
    }
    printf(" Reading : W:%d H:%d\n", *width, *height);


    // Read image data
    for (int i = 0; i < *height; i++) {
        for (int j = 0; j < *width; j++) {
            fscanf(fp, "%u", &img[i][j]);
        }
    }
    
   
    fclose(fp);
}

/// @brief Escribe en un nuevo archivo outpup.pgm el arreglo pixels modificado
/// @param filename 
/// @param pixels 
/// @param rows 
/// @param cols 
void write_pgm(char *filename, unsigned char pixels[MAX_H_PIXELS][MAX_W_PIXELS], int rows, int cols) {
    FILE *fp = fopen(filename, "w");

    // Escribimos la cabecera del archivo PGM
    fprintf(fp, "P2\n");
    fprintf(fp, "%d %d\n", cols, rows);
    fprintf(fp, "255\n");

    // Escribimos los valores de los pixeles
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            fprintf(fp, "%u ", pixels[i][j]);
        }
        fprintf(fp, "\n");
    }

    fclose(fp);
}

/// @brief Modifica el array de pixeles original solo 1/4 de la imagen
/// @param arg 
void change (int arg){
    int id = arg;
    int rw;
    int cl;
    int limIzq;
    int limDer;
    int limArr;
    int limAba;
    int mask[3][3] = {{-1, -1, -1}, {-1, 9, -1}, {-1, -1, -1}}; // Máscara para el filtro de realce de bordes
    unsigned char suma =0;
    int rows_ = rows;
    int cols_ = cols;

    if(id==1){
        rw = (int) rows_/2;
        cl = (int) cols_/2;
        limIzq = 0;
        limDer = cl-1;
        limArr = 0;
        limAba = rw-1;
    }else if(id==2){
        rw = (int) rows_/2;
        cl = cols - (int) cols_/2;
        limIzq = (int) (cols_/2)-1;
        limDer = cols_-1;
        limArr = 0;
        limAba = rw-1;
    }else if(id==3){
        rw = rows - (int) rows_/2;
        cl = (int) cols_/2;
        limIzq = 0;
        limDer = cl-1;
        limArr = (int) (rows_/2)-1;
        limAba = rows_-1;
    }else if(id==4){
        rw = rows - (int) rows_/2;
        cl = cols - (int) cols_/2;
        limIzq = (int) (cols_/2)-1;
        limDer = cols_-1;
        limArr = (int) (rows_/2)-1;
        limAba = rows_-1;
    }
    
    //printf("id[%d]  %d %d %d %d\n",id,limIzq,limDer,limArr,limAba);
    // Aplicamos el filtro de realce de bordes
    for (int i = limArr+1; i < limAba; i++) {
        for (int j = limIzq+1; j < limDer; j++) {
            suma = 0;
            for (int k = -1; k <= 1; k++) {
                for (int l = -1; l <= 1; l++) {
                    suma += pixels[i+k][j+l] * mask[k+1][l+1];
                }
            }
            result[i][j] = truncateMy(suma);
        }
    }

    // Copiamos los valores del resultado al arreglo de pixeles original
    for (int i = limArr; i <=limAba; i++) {
        for (int j = limIzq; j <= limDer; j++) {
            pixels[i][j] = result[i][j];
        }
    }

    printf("\nFiltro terminado\n");
    

}




void *
leer_original_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * resulta;
	getrlimit(RLIMIT_STACK, &limit);
    limit.rlim_cur = 1 * 1024 * 1024 *1024;
    setrlimit(RLIMIT_STACK, &limit);
    printf("\nStack limit: %lu\n", limit.rlim_cur);
	
	read_pgm("input.pgm", pixels, &cols, &rows);

	/*
	 * insert server code here
	 */

	return (void *) &resulta;
}

void *
filtrar_imagen_1_svc(int *argp, struct svc_req *rqstp)
{
	// Ampliar el maximo de espacio de estack del proceso

    getrlimit(RLIMIT_STACK, &limit);
    limit.rlim_cur = 1 * 1024 * 1024 *1024;
    setrlimit(RLIMIT_STACK, &limit);
    printf("\nStack limit: %lu\n", limit.rlim_cur);
	static char * resulta;
	//leer el archivo y llenar el array de pixeles y row y cols

    printf("\nFiltering %d/4\n", *argp);

	switch (*argp)
	{
	case 1:
        printf("\nPc 1 filter on process\n");
		change(1);
		break;
	case 2:
        printf("\nPc 2 filter on process\n");
		change(2);
		break;
	case 3:
        printf("\nPc 3 filter on process\n");
		change(3);
		break;
	case 4:
        printf("\nPc 4 filter on process\n");
		change(4);
		break;
	
	default:
		break;
	}


	


}

void *
escribir_output_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * resulta;

	/*
	 * insert server code here
	 */
	write_pgm("output.pgm", pixels, rows, cols);
	seeFile();
	return (void *) &resulta;
}
